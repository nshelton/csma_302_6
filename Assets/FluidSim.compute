#pragma kernel Test
#pragma kernel Clear
#pragma kernel Advection
#pragma kernel Force
#pragma kernel Diffuse
#pragma kernel Divergence
#pragma kernel ProjectField
#pragma kernel Pressure
#pragma kernel BoundaryPressure
#pragma kernel BoundaryVelocity

// contains x, y, velocity, z concentration
Texture2D<float4> _SourceFluid;
Texture2D<float4> _SourcePressure;
Texture2D<float4> _SourceDivergence;

RWTexture2D<float4> _DestinationFluid;
RWTexture2D<float4> _DestinationPressure;
RWTexture2D<float4> _DestinationDivergence;

float _resolution;
float _viscosity;
float _dt;

float _rBeta;
float _alpha;
float _halfrdx;
float _rdx;
float _dampening;

//in pixel coordinates
float3 _mousePos;
float3 _mouseVelocity;
float _decay;

SamplerState MyLinearRepeatSampler;

float4 SampleLinear(float2 uv)  {
    return _SourceFluid.SampleLevel(MyLinearRepeatSampler, saturate(uv), 0);
}

[numthreads(8,8,1)]
void Test (uint3 id : SV_DispatchThreadID)
{
    float2 pos =  ((float2)id.xy + float2(0.5, 0.5)) / _resolution - 0.5;

    float concentration = 0;
    float2 velocity = float2(0, 0);

    if (length(pos) < 0.1) {
        concentration = 1;
        velocity = float2(0, 0.1);
    }

   _DestinationFluid[id.xy] += float4(velocity, concentration, 0);
}

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    _DestinationFluid[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(8,8,1)]
void Advection (uint3 id : SV_DispatchThreadID)
{
    float2 velocity = _SourceFluid[id.xy].xy;

    float2 pos = ((float2)id.xy + float2(0.5, 0.5)) / _resolution;

    pos -= velocity * _dt;

    float4 previous = SampleLinear(pos);

    previous.z *= _decay;
    _DestinationFluid[id.xy] = previous;
}

[numthreads(8,8,1)]
void Force (uint3 id : SV_DispatchThreadID)
{
    float4 result = float4(0, 0, 0, 0);

    if (distance(id.xy, _mousePos.xy) < 10) {
        result.xy = _mouseVelocity.xy;
        result.z = 1;
    }

    _DestinationFluid[id.xy] += result;
}

[numthreads(8,8,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
    float4 laplacian = 
        _SourceFluid[id.xy + uint2(-1,  0)] +
        _SourceFluid[id.xy + uint2( 1,  0)] +
        _SourceFluid[id.xy + uint2( 0, -1)] + 
        _SourceFluid[id.xy + uint2( 0,  1)] -
        4 * _SourceFluid[id.xy];

    // diffuse velocity, not the concentration
    float4 result = _SourceFluid[id.xy];
    result.xy += laplacian.xy * _viscosity * _dt;

    _DestinationFluid[id.xy] = result;
}

[numthreads(8,8,1)]
void Divergence (uint3 id : SV_DispatchThreadID)
{
    float4 L = _SourceFluid[id.xy + uint2(-1,  0)]; 
    float4 R = _SourceFluid[id.xy + uint2( 1,  0)];

    float4 D = _SourceFluid[id.xy + uint2( 0, -1)];
    float4 U = _SourceFluid[id.xy + uint2( 0,  1)];

    float div = ((R.x - L.x) + (U.y - D.y)) * _halfrdx;

    _DestinationDivergence[id.xy] = float4(div, div, div, div);
}

[numthreads(8,8,1)]
void ProjectField (uint3 id : SV_DispatchThreadID)
{
    float L = _SourcePressure[id.xy + uint2(-1,  0)].x; 
    float R = _SourcePressure[id.xy + uint2( 1,  0)].x;

    float D = _SourcePressure[id.xy + uint2( 0, -1)].x;
    float U = _SourcePressure[id.xy + uint2( 0,  1)].x;

    float2 grad = float2(R - L, U - D) * _halfrdx;

    float4 result = _SourceFluid[id.xy];
    result.xy -= grad;

    _DestinationFluid[id.xy] = result;
}

[numthreads(8,8,1)]
void Pressure (uint3 id : SV_DispatchThreadID)
{
    // left, right, bottom, and top x samples
    float4 L = _SourcePressure[id.xy + uint2(-1,  0)]; 
    float4 R = _SourcePressure[id.xy + uint2( 1,  0)];

    float4 B = _SourcePressure[id.xy + uint2( 0, -1)];
    float4 T = _SourcePressure[id.xy + uint2( 0,  1)];

    // b sample, from center
    float4 bC = _SourceDivergence[id.xy];

    // evaluate Jacobi iteration
    float4 xNew = (L + R + B + T + _alpha * bC) * 0.25;

    _DestinationPressure[id.xy] = xNew;
}

[numthreads(8, 8, 1)]
void BoundaryPressure (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0) {
        float4 result = _SourceFluid[id.xy + uint2(1, 0)];
    }

    if (id.x == _resolution - 1) {
        float4 result = _SourceFluid[id.xy - uint2(1, 0)];
    }

    if (id.y == 0) {
        float4 result = _SourceFluid[id.xy + uint2(0, 1)];
    }

    if (id.y == _resolution - 1) {
        float4 result = _SourceFluid[id.xy - uint2(0, 1)];
    }
}

[numthreads(8, 8, 1)]
void BoundaryVelocity (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0) {
        float4 result = _SourceFluid[id.xy + uint2(1, 0)];
        _DestinationFluid[id.xy] = result * float4(-1, -1, 1, 1);
    }

    if (id.x == _resolution - 1) {
        float4 result = _SourceFluid[id.xy - uint2(1, 0)];
        _DestinationFluid[id.xy] = result * float4(-1, -1, 1, 1);
    }

    if (id.y == 0) {
        float4 result = _SourceFluid[id.xy + uint2(0, 1)];
        _DestinationFluid[id.xy] = result * float4(-1, -1, 1, 1);
    }

    if (id.y == _resolution - 1) {
        float4 result = _SourceFluid[id.xy - uint2(0, 1)];
        _DestinationFluid[id.xy] = result * float4(-1, -1, 1, 1);
    }

    float2 pos = ((float2)id.xy + float2(0.5, 0.5)) / _resolution - 0.5;

    //if (length(frac(pos * 4) - 0.5) < 0.1) {
    //    _DestinationFluid[id.xy] = float4(0, 0, 0, 0);
    //}
}

